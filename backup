#!/bin/bash

VERSION="1.3.1"
FOLDER="$HOME/.backup"
CONFIG_FILE="$HOME/.backup/backup.conf"
DEFAULT_LIST="$HOME/.backup/backup.list"
DEFAULT_BACKUP_LOCATION="$HOME/.backup/backup"
DEFAULT_BACKUP_COUNT=50
PROGNAME="$(basename $0)"
MYSELF="$(realpath $0)"
BACKUP_MODE="AUTOMATIC"

function PrintInfo {
    echo "Info : If you just installed this program"
    echo "          or if it is the first time running it as user $(whoami) please run '$folderName --install-defaults'."
    echo "          to setup backup list use '$PROGNAME -e',"
    echo "          to run the backups use '$PROGNAME -R',"
    echo "          to atomatize operations combine with crontab."
    echo "          for more help '$PROGNAME -h' for error reporting: https://github.com/Reiikz/BashBackupScript/issues"
}

function PrintBackupFolderError {
    echo "Error: ¿did you just touch the backup folder?"
    echo "         or ¿is the script working incorrectly? (It could be just empty though)"
    echo ""
    PrintInfo
}

function CheckConfig {
    if [ ! -e $CONFIG_FILE ]
    then
        mkdir -p $(dirname $CONFIG_FILE)
        WriteConfigFile
    fi
    LoadConfig
    configChecked=1
    if [ ! -e $backup_list ]
    then
        mkdir -p $(dirname $backup_list)
        WriteBackupListExample
    fi
    user=$(whoami)
    #chown $user:$user -R $backup_folder
    #chmod 700 -R $backup_folder >/dev/null 2>&1
    #chown $user:$user -R $(dirname $CONFIG_FILE)
    #chmod 700 -R $(dirname $CONFIG_FILE) >/dev/null 2>&1
    #chown $user:$user -R $(dirname $backup_list)
    #chmod 700 -R $(dirname $backup_list) >/dev/null 2>&1
}

function LoadConfig {
    if [ ! -e $CONFIG_FILE ]
    then
        echo "Config file was missing"
        if [ ! -z "$configChecked" ]
        then
            echo "can not write config file"
            exit 0
        fi
        CheckConfig
    fi
    source $CONFIG_FILE
    if [ ! -z $MB_BACKUP_LIST ]; then
        backup_list=$DEFAULT_LIST
    fi
    if [ ! -z $MB_FOLDER ]; then 
        backup_folder=$MB_FOLDER
    fi
}

function CheckRoot {
    if [ "$(whoami)" != "root" ]
    then
        if [ -z "$SUDO_COMMAND" ]
        then
            echo "please run as root"
            exit 1
        fi
    fi
}

function WriteConfigFile {
    echo "Writing config on: $CONFIG_FILE"
    mkdir -p $DEFAULT_BACKUP_LOCATION
    echo "#where should the backups should be stored?" > $CONFIG_FILE
    echo "backup_folder=$DEFAULT_BACKUP_LOCATION" >> $CONFIG_FILE
    echo "" >> $CONFIG_FILE

    echo "#Where is located the file with the backup list?" >> $CONFIG_FILE
    echo "backup_list=\"$DEFAULT_LIST\"" >> $CONFIG_FILE
    chmod 700 $CONFIG_FILE
    echo "if no other prompt in between; operation complete!"
}

function WriteBackupListExample {
    echo "Writing backup list on: $DEFAULT_LIST"
    mkdir -p $DEFAULT_BACKUP_LOCATION
    echo "invalid" > $DEFAULT_LIST
    echo "this is an example of the backup list" >> $DEFAULT_LIST
    echo "this file should have only the paths and the backup file names" >> $DEFAULT_LIST
    echo "otherwise it'll be invalid" >> $DEFAULT_LIST
    echo "you have to write the path in the inmediate line the backup name" >> $DEFAULT_LIST
    echo "and then the maximum number of stored backups for that path" >> $DEFAULT_LIST
    echo "there should be no lines in between or extra linejumps 'cause the script will read it as another file" >> $DEFAULT_LIST
    echo "" >> $DEFAULT_LIST
    echo "like this:" >> $DEFAULT_LIST
    echo "" >> $DEFAULT_LIST
    echo "fake-file" >> $DEFAULT_LIST
    echo "/fake/path" >> $DEFAULT_LIST
    echo "20" >> $DEFAULT_LIST
    echo "fake-file-2" >> $DEFAULT_LIST
    echo "/fake/path2" >> $DEFAULT_LIST
    echo "25" >> $DEFAULT_LIST
    echo "super_vaca_powers_config_backup" >> $DEFAULT_LIST
    echo "/etc/apt" >> $DEFAULT_LIST
    echo "1000000" >> $DEFAULT_LIST
    echo "if no other prompt in between; operation complete!"
}

function PrintHelp {
    echo "Usage:"
    echo "  $PROGNAME -R                                                                       run the configured backups"
    echo "  $PROGNAME -b <backup-name> -f <file-path> [OPTIONAL]-n <max-copys>                 backs up a file for you"
    echo "  $PROGNAME -r <backup-name>                                                         restore a backup"
    echo "  $PROGNAME -l                                                                       lists all backups"
    echo "  $PROGNAME -L <backup-name>                                                         lists all storedes versions"
    echo "  $PROGNAME -d <backup-name>                                                         remove all backups"
    echo "  $PROGNAME -D <backup-name>                                                         delete specific backup file"
    echo "  $PROGNAME -e                                                                       edit the list"
    echo "  $PROGNAME -E                                                                       edit settings"
    echo "  $PROGNAME -v                                                                       Version"
    echo "  $PROGNAME -g <output-path> <backup-name>                                           returns the backup"
    echo "  $PROGNAME -x <output-path>                                                         returns a specific backup"
    echo "  $PROGNAME -P <output-file>                                                         packages all the backups and config and outputs the file"
    echo "  $PROGNAME -S <input-file>                                                          imports backups and config"
    echo "  $PROGNAME -w                                                                       se backup folder"
    echo "  $PROGNAME -W                                                                       prints the backup folder location"
    echo "  $PROGNAME -G <output-file>                                                         outputs a backup of all your backups for specific origin"
    echo "  $PROGNAME -s <input-file>                                                          restores a backup all your backups for specific"
    echo "  $PROGNAME -o also restores the configuration for that backup when combined with -s"
    echo "Is recomended the use of absolute paths"
    echo "for more info use man $PROGNAME"
}

function PrintVersion {
    echo "$PROGNAME command, version $VERSION"
    echo "Copyright (c) 2019"
    echo "License GNU/GPLv3"
    echo "Source on: https://github.com/Reiikz/BashBackupScript"
}

function LoadBackupList {
    readarray -t PathList < $backup_list
    if [ "${PathList[0]}" == "invalid" ]
    then
        echo ""
        echo "the path list file is the example one, please fix it, it is located at ->"
        echo "          $backup_list"
        echo "or you can use $PROGNAME -e to directly open it"
        echo ""
        exit 0
    fi
}

function LoadBackupCfg {
    CheckConfig
    LoadBackupList
}

function GetFile {
    folder=$1
    if [ ! -e "$folder" ]
    then
        echo "the backup $1 doesn't exist"
        echo "To list backups and see wich are there and the last update use '$PROGNAME -l'"
        echo "To list all backups for specific file use '$PROGNAME -L <backup-name>'"
        exit 0
    fi

    folderCount=$(wc -l $folder/backupFolders | cut -d' ' -f 1)
    if [ $folderCount == 1 ]
    then
        dateFile=$folder/backups-$(cat $folder/backupFolders)
        filesCount=$(wc -l $dateFile | cut -d' ' -f 1)
        date=$(cat $folder/backupFolders)
        if [ $filesCount == 1 ]
        then
            file=$(cat $dateFile)
        else
            readarray -t files < "$dateFile"
            i=0
            for item in ${files[@]}
            do
                echo "   File #$i: $item"
                echo "      created at: $(cat $item.time)"
		echo "      tag       : $(cat $item.tag)"
		echo "      MODE      : $(cat $item.mode)"
                echo ""
                i=$(($i+1))
            done
            echo "Type the number of the file you wanna select"
            echo -n "then press [Enter]: "
            read number
            if [ -z $number ]
            then
                echo "Invalid input"
                exit 0
            fi
            if [ $number -gt $(($filesCount-1)) ]
            then
                echo "number too big"
                exit 0
            fi
            file=${files[$number]}
        fi
    else
        echo "Type de date of the copy you wanna select"
        echo -n "   Type the day and press [ENTER]: "
        read day
        echo -n "   Type the month and press [ENTER]: "
        read month
        echo -n "   Type the year and press [ENTER]: "
        read year
        date=$(date -d "$month/$day/$year" "+%d-%m-%Y")
        if [ ! -e "$folder/$date" ]
        then
            echo "that date doesn't exist"
            exit 0
        fi
        dateFile=$folder/backups-$date
        filesCount=$(wc -l $dateFile | cut -d' ' -f 1)
        if [ $filesCount == 1 ]
        then
            file=$(cat $dateFile)
        else
            readarray -t files < "$dateFile"
            i=0
            for item in ${files[@]}
            do
                echo "   File #$i: $item"
		echo "      created at: $(cat $item.time)"
		echo "      tag       : $(cat $item.tag)"
		echo "      MODE      : $(cat $item.mode)"
                i=$(($i+1))
            done
            echo "Type the number of the file you wanna select"
            echo -n "then press [Enter]: "
            read number
            if [ $number -gt $(($filesCount-1)) ]
            then
                echo "number too big"
                exit 0
            fi
            file=${files[$number]}
        fi
    fi
}

function DoBackup {
    i=0
    origin=""
    destination=""
    maxCopys=0
    infoFileFolders=""
    infoFileBackup=""
    folderName=""

    for item in ${PathList[@]}
    do
        case $i in

            0)
                folderName="$item"
                i=$((i+1))
            ;;

            1)
                origin="$item"
                i=$((i+1))

                if [ ! -e "$backup_folder/$folderName" ]; then
                    mkdir -p "$backup_folder/$folderName"
                fi

                infoFileFolders="$backup_folder/$folderName/backupFolders"
                infoFileBackup="$backup_folder/$folderName/backups-$(date +%d-%m-%Y)"
                infoFileLastBackup="$backup_folder/$folderName/lastBackup"
                destinationFolder="$backup_folder/$folderName/$(date +%d-%m-%Y)"
                destination="$destinationFolder/$folderName-$(date +%H-%M-%S).tar"
                mkdir -p $(dirname $destination)
                echo "$BACKUP_MODE" > "$backup_folder/$folderName/backupMode"
                echo "$(date "+%d/%m/%Y ::: %H:%M:%S")" > $destination.time
                echo "$BACKUP_TAG" > $destination.tag
                echo "$BACKUP_MODE" > $destination.mode
                echo "$(date "+%d-%m-%Y")" > $infoFileLastBackup
                echo "$(date "+%H:%M:%S")" > "$backup_folder/$folderName/lastTime"
                mkdir -p $destinationFolder
                
                echo "$origin" > "$backup_folder/$folderName/origin"
                                
                lastBackup=""
                if [ -e "$infoFileLastBackup" ]
                then
                    lastBackup=$(cat $infoFileLastBackup)
                fi

                date=$(date "+%d-%m-%Y")
                if [ ! -e "$infoFileFolders" ]
                then
                    echo "$date" >> $infoFileFolders
                else
                    alreadyHasIt=$(grep -F "$date" $infoFileFolders)
                    if [ -z "$alreadyHasIt" ]
                    then
                        echo "$date" >> $infoFileFolders
                    fi
                fi

                if [ ! -e "$infoFileBackup" ]
                then
                    echo "$destination" > $infoFileBackup
                else
                    echo "$destination" >> $infoFileBackup
                fi
            ;;

            2)
                maxCopys=$item
                echo ""
                echo "Backing up   : $folderName"
                echo "path         : $origin"
                if [ ! -e "$origin" ]
                then

                    echo "Invalid backup path"
                    exit 0
                fi

                cd $(dirname $origin)
                tar -cf "$destination" "$(basename $origin)"

                if [ ! -z "$GetBackup" ]
                then
                    cp $destination $GetBackup
                fi

                numberOfDates=$(echo $(wc -l $infoFileFolders) | cut -d' ' -f 1)
                readarray -t dates < "$infoFileFolders"
                files=""
                copysToErase=0

                declare -A NumberOfFilesByDate
                totalNumber=0
                EraseExtraCopys $maxCopys $folderName
                i=0
            ;;

        esac

    done

}

function EraseExtraCopys {
    local maxCopys=$1
    local folderName=$2
    local folderPath=$backup_folder/$2
    cd $folderPath
    local folderCount=$(wc -l "backupFolders" | cut -d' ' -f 1)
    echo "Max copys    : $maxCopys"
    if [ $folderCount == 1 ]
    then
        local files
        date=$(cat "backupFolders")
        numberFilesOnFolder=$(wc -l "backups-$date" | cut -d' ' -f 1)
        echo "Backup Number: $numberFilesOnFolder"
        copysToErase=$(($numberFilesOnFolder-$maxCopys))
        if [ $copysToErase -gt 0 ]
        then
            readarray -t files < "backups-$date"
            erasedCopys=0
            rm "backups-$date"
            for file in ${files[@]}
            do
                filemode="$(cat $file.mode)"
                if [ $erasedCopys -lt $copysToErase ] && [ "$filemode" == "AUTOMATIC" ]
                then
                    rm $file
                    rm $file.*
                    erasedCopys=$(($erasedCopys+1))
                else
                    echo "$file" >> "backups-$date"
                fi
            done
        fi
    else
        readarray -t folders < "backupFolders"
        declare -A numberFilesByDate
        totalFiles=0
        for date in ${folders[@]}
        do
            number=$(wc -l "backups-$date" | cut -d' ' -f 1)
            numberFilesByDate["$date"]=$number
            totalFiles=$(($number+$totalFiles))
        done
        echo "Backup Number: $totalFiles"
        if [ $totalFiles -gt $maxCopys ]
        then
            copysToErase=$(($totalFiles-$maxCopys))
            declare -A files
            for date in ${folders[@]}
            do
                readarray -t fileList < "backups-$date"
                for i in $( seq 0 $((${#fileList[@]}-1)) )
                do
                    files[$date,$i]=${fileList[$i]}
                done
            done
            erasedCopys=0
            declare -A erasedCopysOnDate
            erasedCopysOnDate["${folders[0]}"]=0
            dateNumber=0
            while [ $erasedCopys -lt $copysToErase ]
            do
                date=${folders[$dateNumber]}
                if [ ${erasedCopysOnDate[$date]} -lt ${numberFilesByDate[$date]} ]
                then
                    file=${files[$date,${erasedCopysOnDate[$date]}]}
                    filemode="$(cat $file.mode)"
                    if [ "$filemode" == "AUTOMATIC" ]; then
                        rm $file
                        rm $file.*
                        grep -v "${files[$date,${erasedCopysOnDate[$date]}]}" "backups-$date" > temp
                        rm "backups-$date"
                        mv "temp" "backups-$date"
                        erasedCopys=$(($erasedCopys+1))
                    else
                        DATEHASMANUALRUN=1
                    fi
                    erasedCopysOnDate[${folders[$dateNumber]}]=$((${erasedCopysOnDate[$date]}+1))
                else
                    if [ -z $DATEHASMANUALRUN ]; then
                        rmdir $date
                        rm "backups-$date"
                        grep -v "$date" "backupFolders" > temp
                        rm "backupFolders"
                        mv "temp" "backupFolders"
                    else
                        unset DATEHASMANUALRUN
                    fi
                    dateNumber=$(($dateNumber+1))
                    erasedCopysOnDate[${folders[$dateNumber]}]=0
                fi
            done
        fi
    fi
    if [ -z "$erasedCopys" ]
    then
        erasedCopys=0
    fi
    echo "Erased       : $erasedCopys old copy/s"
    echo "Last Backup  : $(cat $folderPath/lastBackup) ::: $(cat $folderPath/lastTime)"
    echo "TAG:         : $BACKUP_TAG"
    echo "MODE:        : $BACKUP_MODE"
    echo ""
}

function RestoreFile {
    LoadConfig
    origin=$(cat $1/origin)
    rm -rf "$origin"
    mkdir -p $(dirname $origin)
    tar -xf $2 --directory $(dirname $origin)
    echo "Restored file: $origin"
}

function Resotore {
    if [ -z $MB_FOLDER ]; then
        LoadConfig
    else
        backup_folder=$MB_FOLDER
    fi
    folder="$backup_folder/$1"
    GetFile $folder
    RestoreFile $folder $file
}

function ListAllBackups {
    LoadConfig
    echo ""
    for item in $backup_folder/*/
    do
        if [ ! -e $item ]
        then
            echo "$item not found"
            PrintBackupFolderError
            exit 0
        fi
        echo "Backup: $(basename $item)"
        #echo "  Last updated: $(cat $item/lastBackup)  $(cat $item/lastTime)"
        file=$(tail $item/backups-$(cat $item/lastBackup) --lines=1)
        echo "      $file"
        if [ ! -e "$file.time" ]
        then
            echo "file: $file.time"
            echo "      containg time at wich the file was created was missing, this could cause errors"
            PrintBackupFolderError
        fi
        if [ ! -e "$file.tag" ]
        then
            echo "file: $file.tag"
            echo "      containg tag with wich the file was created was missing"
            PrintBackupFolderError
        fi
        echo "          created at: $(cat $file.time)"
        echo "          tag       : $(cat $file.tag)"
        echo "          mode      : $(cat $file.mode)"
    done
    echo ""
}

function ListBackups {
    LoadConfig
    echo ""
    folder="$backup_folder/$1"
    if [ ! -e $folder ]
    then
        echo "that backup doesn't exist"
        exit 0
    fi
    readarray -t dates < "$folder/backupFolders"
    echo ${dates[@]}
    echo "Backups of: $1:"
    for item in ${dates[@]}
    do
        echo "  On date $item:"
        readarray -t files < "$folder/backups-$item"
        for item2 in ${files[@]}
        do
            if [ ! -e "$item2.time" ]
            then
                echo "$item2.time  was missing, exiting.."
                exit 0
            fi
            echo "      File: $item2"
            echo "          Created at: $(cat $item2.time)"
            echo "          tag       : $(cat $item2.tag)"
            echo "          mode      : $(cat $item2.mode)"
            echo ""
        done
    done
    echo ""
    echo "Last backup was: $(tail $folder/backups-$(tail $folder/backupFolders --lines=1) --lines=1)"
    echo "On             : $(cat $folder/lastBackup) :at: $(cat $folder/lastTime)"
    echo ""
}

function GetEditor {
    LoadConfig
    if [ -z "$editor" ]
    then
        echo -n "Type the executable of your text editor and press [ENTER]: "
        read editor
        echo "the path to the editor is: $editor"
        echo -n "is that correct? [y/n]: "
        read response
        while [ "$response" != "y" ]
        do
            echo -n "Type the executable of your text editor and press [ENTER]: "
            read editor
            echo "the path to the editor is: $editor"
            echo -n "is that correct? [y/n]: "
            read response
        done
        echo "" >> $CONFIG_FILE
        echo "#your preferred textfile editor" >> $CONFIG_FILE
        echo "editor=$editor" >> $CONFIG_FILE
    fi
}

function EditList {
    GetEditor
    $editor $backup_list
}

function EditConfig {
    GetEditor
    $editor $CONFIG_FILE
}

function RemoveBackup {
    chmod 700 -R $FOLDER >/dev/null 2>&1
    LoadConfig
    folder=$backup_folder/$1
    if [ ! -e $folder ]
    then
        echo "that backup doesn't exist"
    else
        echo "you are about to delete all your backups on: $1"
        echo -n "are you sure? [YES/n]: "
        read response
        if [ "$response" == "YES" ]
        then
            rm -rf $folder
        else
            echo "You scared me :v"
        fi
    fi
}

function DeleteSpecificBackup {
    LoadConfig
    folder="$backup_folder/$1"
    if [ ! -e "$folder" ]
    then
        echo "that backup doesn't exist"
        exit 0
    fi
    GetFile $folder
    echo "Are you sure you wanna delete the folloing backup?:"
    echo "          $file"
    echo -n "[YES/n]: "
    read response
    if [ "$response" == "YES" ]
    then
        rm $file
        readarray -t files < "$folder/backups-$date"
        rm "$folder/backups-$date"
        for item in ${files[@]}
        do
            if [ -e "$item" ]
            then
                echo "$item" >> "$folder/backups-$date"
            fi
        done
    else
        exit 0
    fi
}

function ExportAll {
    LoadConfig
    echo "$(basename $CONFIG_FILE)" >> names
    echo "$(basename $backup_list)" >> names
    echo "$(basename $backup_folder)" >> names
    outputFile=$(realpath $1 -L)
    tar -cf $outputFile names
    rm names
    cd $(dirname $backup_folder)
    tar -f $outputFile -r $(basename $backup_folder)
    cd $(dirname $CONFIG_FILE)
    tar -f $outputFile -r $(basename "$CONFIG_FILE")
    cd $(dirname $backup_list)
    tar -f $outputFile -r $(basename "$backup_list")
}

function ImportAll {
    if [ ! -e "$1" ]
    then
        "the file $1 does not exist"
        exit 0
    fi
    tar -xf $1
    readarray -t names < "names"
    configFileName=${names[0]}
    tar -cf $1 $configFileName
    rm -rf $CONFIG_FILE
    mkdir -p $(dirname $CONFIG_FILE)
    mv $configFileName $CONFIG_FILE
    LoadConfig
    rm -rf $backup_list
    mv ${names[1]} $backup_list
    rm -rf $backup_folder
    mv ${names[2]} $backup_folder/
    rm -rf names
    rm $1
}

function OpenBackupFolder {
    LoadConfig
    if [ -z "$file_explorer" ]
    then
        echo -n "Type your file explorer and press [ENTER]: "
        read fileExplorer
        echo "" >> $CONFIG_FILE
        echo "#this is the executable of your file explorer, if you wanna use the terminal change it for cd" >> $CONFIG_FILE
        echo "#if you wanna use for example cinnamon's file explorer change it for \"nemo\"" >> $CONFIG_FILE
        echo "file_explorer=$fileExplorer" >> $CONFIG_FILE
        $fileExplorer $backup_folder
    else
        $file_explorer $backup_folder
    fi
}

function SaveBackupOfBuckups {
    LoadConfig
    pFolder=$(realpath -L $1)
    cd $backup_folder
    echo -n "Type the backup name and press [ENTER]: "
    read backup
    if [ ! -e "$backup" ]
    then
        echo "that backup doesn't exist"
    fi
    origin=$(cat $backup/origin)
    
    #get backup quantity
    LoadBackupList
    i=0
    now=0
    for item in ${backup_list[@]}
    do
        if [ $item == $origin ]
        then
            now=1
        fi

        if [ $now == 1 ]
        then
            if [ $i == 2 ]
            then
                quantity=$item
            fi
        fi

        if [ $i -lt 2 ]
        then
            i=$(($i+1))
        else
            i=0
        fi
    done

    if [ -z "$quantity"]
    then
        quantity=20
    fi

    echo "#!/bin/bash" >> info
    echo "origin=$origin" >> info
    echo "name=$backup" >> info
    echo "quantity=$quantity" >> info
    chmod +x info

    tar -cf $pFolder $backup info
    rm info
}

function RestoreBackupOfBackup {
    LoadConfig
    cd $(dirname $1)
    tar -xf $(basename $1)
    if [ ! -e "info" ]
    then
        echo "missing info file"
    fi
    chmod +x info
    source info
    mv $name $backup_folder
    if [ ! -z "$RESTORE_OLD_CFG" ]
    then
        rm info
    else
        LoadBackupList
        for item in ${backup_list[@]}
        do
            if [ $item == $origin ]
            then
                exists=1
            fi
        done

        if [ -z "$exists" ]
        then
            LoadConfig
            echo "$origin" >> $backup_list
            echo "$name" >> $backup_list
            echo "$quantity" >> $backup_list
        fi
        rm info
    fi

}

function ReturnBackup {
    ListAllBackups
    echo "please input the backup name you wanna restore"
    echo -n "then press [ENTER]: "
    read name
    GetFile $backup_folder/$name
    cp $file $1
}

function CheckFirstArgument {
    if [ "$notFirst" != "" ]; then
        echo ""
        echo "Operation argument must be the first one"
        echo ""
        exit 1
    fi
}

function GetBackup {
    LoadConfig
    if [ "$2" != "" ]; then
        name=$2
    else
        echo -n "Type the name of the backup and press [ENTER]: "
        read name
    fi
    folder=$backup_folder/$name
    echo "$folder"
    GetFile $folder
    cp $file $1
}

function ValidateDirectory {
    if [ ! -e $1 ]; then
        mkdir -p $1
    fi
    if [ ! -d $1 ]; then
        echo "provided path is already exists and is not directory"
    fi
}

function ManualBackup {
    if [ -z $MB_NAME ]; then
            echo "required --backup-name when running --manual-backup"
            exit 1
        fi

        if [ -z $DEFAULT_DIRECTORY ] && [ -z $MB_FOLDER ]; then
            echo "required --backup-folder or --default-directory when running --manual-backup"
            exit 1
        fi
        
        ValidateDirectory $MB_FOLDER
        if [ -z $MB_COUNT ]; then
            if [ ! -z $DEFAULT_DIRECTORY ]; then
                LoadBackupCfg
                i=0
                for item in ${PathList[@]}; do
                    if [ "$item" == "$MB_NAME" ]; then
                        i=$(($i+2))
                        MB_COUNT=${PathList[$i]}
                        FOUND_BACKUP=1
                        break
                    fi
                    i=$(($i+1))
                done
                if [ -z $FOUND_BACKUP ]; then
                    MB_COUNT=$DEFAULT_BACKUP_COUNT
                fi
                unset PathList
            else
                MB_COUNT=$DEFAULT_BACKUP_COUNT
            fi
        fi

        if [ ! -z $DEFAULT_DIRECTORY ]; then
            LoadConfig
        else
            backup_folder=$MB_FOLDER
        fi
        declare -a PathList=("$MB_NAME" "$MB_TARGET" "$MB_COUNT")
        DoBackup
}

if [ $# -eq 0 ]; then
    PrintInfo
    exit 0
fi

operation=""
while [ "$1" != "" ]; do
    
    case $1 in
        -g|--export-backup)
            CheckFirstArgument
            operation="GetBackup"
            shift
            if [ "$1" == "" ]; then
                echo "missing argument, must be <filename.tar> <backupname>"
                exit 1
            else
                data=$1
            fi
            shift
            if [ "$1" == "" ]; then
                echo "missing argument, must be <filename.tar> <backupname>"
                exit 1
            else
                data="$data $1"
            fi
        ;;

        -R|--run-backup|--run)
            BACKUP_MODE="AUTOMATIC"
            CheckFirstArgument
            operation="DoBackup"
        ;;

        -RR|--m-run|--mrun|--manual-run)
            BACKUP_MODE="MANUAL"
            CheckFirstArgument
            operation="DoBackup"
        ;;

        -b|--manual-backup)
            CheckFirstArgument
            operation="ManualBackup"
        ;;
        
        -bb|--manual-backup-run)
            CheckFirstArgument
            operation="ManualBackup"
        ;;

        -mm|--is-manual)
            BACKUP_MODE="MANUAL"
        ;;

        --target-path)
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME [options] --target-path <target-file/folder>"
                exit 1
            fi
            MB_TARGET=$1
        ;;
        
        --backup-count)
            shift
            if [ "$1" == "" ]; then
                MB_COUNT=DEFAULT_BACKUP_COUNT
            else
                MB_COUNT=$1
            fi
        ;;

        --backup-name)
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME [options] --backup-name <backup name>"
                exit 1
            fi
            MB_NAME=$1
        ;;

        -e|--edit-backup-list)
            operation="EditList"
        ;;

        --config-file)
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME [options] --config-file <config-file-full-path>"
                exit 1
            fi
            CONFIG_FILE=$1
            if [ ! -e "$1" ]; then
                echo -n "Supplied config file doesn't exist ¿create it? [Y/N]"
                read opt
                if [ "$opt" == "y" ] || [ "$opt" == "y" ]; then
                    WriteConfigFile
                else
                    exit 0
                fi
            fi
        ;;

        --backup-list)
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME [options] --backup-list <list-full-path>"
                exit 1
            fi
            MB_BACKUP_LIST=1
            DEFAULT_LIST=$1
            backup_list=$1
            if [ ! -e "$1" ]; then
                WriteBackupListExample
            fi
        ;;

        --backup-folder)
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME [options] --backup-folder <backup-folder-full-path>"
                exit 1
            fi
            if [ -e "$1" ] && [ ! -d "$1" ]; then
                echo "already exists and is a file"
                exit 1
            fi
            DEFAULT_BACKUP_LOCATION=$1
            backup_folder=$1
            MB_FOLDER=$1
        ;;

        --default-directory)
            DEFAULT_DIRECTORY=1
        ;;

        --uninstall-folder)
            CheckFirstArgument
            echo "About to erase $FOLDER"
            echo -n "[YES I'M FUCKING SHURE/No]: "
            read opt
            if [ "$opt" == "YES I'M FUCKING SHURE" ]; then
                echo -n "erase folder? [Y/N]: "
                read opt
                if [ "$opt" == "Y" ] || [ "$opt" == "y" ]; then
                    rm -rf $FOLDER
                fi
            fi
            exit 0
        ;;

        --install-defaults)
            CheckFirstArgument
            CheckConfig
            exit 0
        ;;

        -r|--restore)
            CheckFirstArgument
            operation="Resotore"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <backup-name>"
                ListAllBackups
                exit 1
            fi
            data=$1
        ;;

        -l|--list-all-backups)
            CheckFirstArgument
            operation="ListAllBackups"
        ;;

        -L|--list-backups)
            CheckFirstArgument
            operation="ListBackups"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <backup-name>"
                ListAllBackups
                exit 1
            fi
            data=$1
        ;;

        -E|--edit-config)
            CheckFirstArgument
            operation="EditConfig"
        ;;

        -h|-H|--help|h|help|HELP|H)
            CheckFirstArgument
            operation="PrintHelp"
        ;;

        -d|--delete-backup)
            CheckFirstArgument
            operation="RemoveBackup"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <backup-name>"
                ListAllBackups
                exit 1
            fi
            data=$1
        ;;

        -v|--version)
            CheckFirstArgument
            operation="PrintVersion"
        ;;

        -D|--delete-backup-file)
            CheckFirstArgument
            operation="DeleteSpecificBackup"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <backup-name>"
                ListAllBackups
                exit 1
            fi
            data=$1
        ;;

        -P|--export-backups)
            CheckFirstArgument
            operation="ExportAll"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <output-file>"
                exit 1
            fi
            data=$1
        ;;

        -S|--import-backups)
            CheckFirstArgument
            operation="ImportAll"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <input-file>"
                exit 1
            fi
            data=$1
        ;;

        -w|--browse-backup-folder)
            CheckFirstArgument
            operation="OpenBackupFolder"
        ;;

        -W|--see-backup-folder)
            CheckFirstArgument
            operation="SeeBackupFolder"
        ;;

        -G|--export-specific)
            CheckFirstArgument
            operation="SaveBackupOfBuckups"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <output-file>"
                exit 1
            fi
            data=$1
        ;;

        -s|--import-specific)
            CheckFirstArgument
            operation="RestoreBackupOfBackup"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <input-file>"
                exit 1
            fi
            data=$1
        ;;

        -o|--also-config)
            RESTORE_OLD_CFG=1
        ;;

        -t|--tag)
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <\"tag\">"
                exit 1
            fi
            BACKUP_TAG=$1
        ;;

        -x|--return-file)
            CheckFirstArgument
            operation="ReturnBackup"
            arg=$1
            shift
            if [ "$1" == "" ]; then
                echo "usage: $PROGNAME $arg <output-file>"
                exit 1
            fi
            data=$1
        ;;

        *)
            echo "$1 not recognized option backup -h for help"
            echo 
            PrintInfo
            exit 0
        ;;
    esac
    shift
    notFirst=1
done

case $operation in
    
    ManualBackup)
        ManualBackup
        exit 0
    ;;

    DoBackup)
        LoadBackupCfg
        if [ ! -z $MB_FOLDER ]; then
            echo "WARNING: BACKUP FOLDER OVERRIDEN, OUTPUT TO-> $MB_FOLDER"
            backup_folder=$MB_FOLDER
        fi
        i=0
        c=0
        if [ ! -z $MB_COUNT ]; then
            echo "WARNING: BACKUP COUNT OVERRIDEN"
            for item in ${PathList[@]}; do
                if [ $i -eq 2 ]; then
                    i=0
                    PathList[$c]=$MB_COUNT
                fi
                c=$(($c+1))
                i=$(($i+1))
            done
        fi
        DoBackup
        exit 0
    ;;

    SeeBackupFolder)
        LoadConfig
        echo "$backup_folder"
    ;;

    *)
        $operation $data
        exit 0
    ;;
esac
