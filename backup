#!/bin/bash
VERSION="1.0.1"
FOLDER="$HOME/.backup"
CONFIG_FILE="$HOME/.backup/backup.conf"
DEFAULT_LIST="$HOME/.backup/backup.list"
DEFAULT_BACKUP_LOCATION="$HOME/.backup/backup"
INSTALL_PATH=/usr/local/bin/backup

function CheckConfig {
    if [ ! -e $CONFIG_FILE ]
    then
        mkdir -p $DEFAULT_BACKUP_LOCATION
        WriteConfigFile
    fi
    LoadConfig
    configChecked=1
    if [ ! -e $backup_list ]
    then
        WriteBackupListExample
    fi
    user=$(whoami)
    chown $user:$user -R $FOLDER
    chmod 700 -R $FOLDER >/dev/null 2>&1
}

function LoadConfig {
    if [ ! -e $CONFIG_FILE ]
    then
        echo "Config file was missing"
        if [ ! -z "$configChecked" ]
        then
            echo "can not write config file"
            exit 0
        fi
        CheckConfig
        exit 0
    fi
    source $CONFIG_FILE
}

function CheckRoot {
    if [ whoami != root ]
    then
        if [ -z "$SUDO_COMMAND" ]
        then
            echo "please run as root"
            exit 1
        fi
    fi
}

function Install {
    if [ "$0" == "$INSTALL_PATH" ]
    then
        echo "the program is already installed"
    else
        CheckRoot
        echo "$(cat $0)" > $INSTALL_PATH
        chmod +x $INSTALL_PATH
    fi
}

function WriteConfigFile {
    mkdir -p $DEFAULT_BACKUP_LOCATION
    echo "#where should the backups should be stored?" > $CONFIG_FILE
    echo "backup_folder=$DEFAULT_BACKUP_LOCATION" >> $CONFIG_FILE
    echo "" >> $CONFIG_FILE

    echo "#Where is located the file with the backup list?" >> $CONFIG_FILE
    echo "backup_list=\"$DEFAULT_LIST\"" >> $CONFIG_FILE
    chmod 700 $CONFIG_FILE
}

function WriteBackupListExample {
    mkdir -p $DEFAULT_BACKUP_LOCATION
    echo "invalid" > $DEFAULT_LIST
    echo "this is an example of the backup list" >> $DEFAULT_LIST
    echo "this file should have only the paths and the backup file names" >> $DEFAULT_LIST
    echo "otherwise it'll be invalid" >> $DEFAULT_LIST
    echo "you have to write the path in the inmediate line the backup file name" >> $DEFAULT_LIST
    echo "and then the maximum number of stored backups for that path" >> $DEFAULT_LIST
    echo "like this:" >> $DEFAULT_LIST
    echo "/fake/path" >> $DEFAULT_LIST
    echo "fake-file" >> $DEFAULT_LIST
    echo "20" >> $DEFAULT_LIST
    echo "/fake/path2" >> $DEFAULT_LIST
    echo "fake-file-2" >> $DEFAULT_LIST
    echo "25" >> $DEFAULT_LIST
}

function PrintHelp {
    echo "Usage:"
    echo "  sudo ./backup -I                                                                installs the program"
    echo "  backup -R                                                                       run the configured backups"
    echo "  backup -b <backup-name> -f <file-path> [OPTIONAL]-n <max-copys>                 backs up a file for you"
    echo "  backup -r <backup-name>                                                         restore a backup"
    echo "  backup -l                                                                       lists all backups"
    echo "  backup -L <backup-name>                                                         lists all storedes versions"
    echo "  backup -d <backup-name>                                                         remove all backups"
    echo "  backup -D <backup-name>                                                         delete specific backup file"
    echo "  backup -c                                                                       cleans up all the data (erases everything)"
    echo "  backup -e                                                                       edit the list"
    echo "  backup -E                                                                       edit settings"
    echo "  backup -i                                                                       installs settings files"
    echo "  backup -v                                                                       Version"
    echo "  backup -g <output-path>                                                         returns the backup"
    echo "  backup -P <output-file>                                                         packages all the backups and config and outputs the file"
    echo "  backup -S <input-file>                                                          imports backups and config"
    echo "(you can combine -g <output-path> with -R or with -b <backup-name> -f <file-path>)"
    echo "Is recomended the use of absolute paths"
}

function PrintVersion {
    echo "backup command, version $VERSION"
    echo "Copyright (c) 2019"
    echo "License GNU/GPLv3"
}

function LoadBackupList {
    readarray -t PathList < $backup_list
    if [ "${PathList[0]}" == "invalid" ]
    then
        echo ""
        echo "the pathlist file is invalid, please fix it, it is located at ->"
        echo "          $backup_list"
        exit 0
    fi
}

function LoadBackupCfg {
    CheckConfig
    if [ -z "$RUN_UNSTORED_BACKUP" ]
    then
        LoadBackupList
    fi
    LoadConfig
}

function GetFile {
    folder=$1
    if [ ! -e "$folder" ]
    then
        echo "that backup doesn't exist"
    fi

    folderCount=$(wc -l $folder/backupFolders | cut -d' ' -f 1)
    if [ $folderCount == 1 ]
    then
        dateFile=$folder/backups-$(cat $folder/backupFolders)
        filesCount=$(wc -l $dateFile | cut -d' ' -f 1)
        date=$(cat $folder/backupFolders)
        if [ $filesCount == 1 ]
        then
            file=$(cat $dateFile)
        else
            readarray -t files < "$dateFile"
            i=0
            for item in ${files[@]}
            do
                echo "   File #$i: $item"
                i=$(($i+1))
            done
            echo "Type the number of the file you wanna select"
            echo -n "then press [Enter]: "
            read number
            if [ -z $number ]
            then
                echo "Invalid input"
                exit 0
            fi
            if [ $number -gt $(($filesCount-1)) ]
            then
                echo "number too big"
                exit 0
            fi
            file=${files[$number]}
        fi
    else
        echo "Type de date of the copu you wanna select"
        echo -n "   Type the day and press [ENTER]: "
        read day
        echo -n "   Type the month and press [ENTER]: "
        ready month
        echo -n "   Type the year and press [ENTER]: "
        read year
        date=$(date -d "$month/$day/$year" "+%d-%m-%Y")
        if [ ! -e "$folder/$date" ]
        then
            echo "that date doesn't exist"
            exit 0
        fi
        dateFile=$folder/backups-$date
        filesCount=$(wc -l $dateFile | cut -d' ' -f 1)
        if [ $filesCount == 1 ]
        then
            file=$(cat $dateFile)
        else
            readarray -t files < "$dateFile"
            i=0
            for item in ${files[@]}
            do
                echo "   File #$i: $item"
                i=$(($i+1))
            done
            echo "Type the number of the file you wanna select"
            echo -n "then press [Enter]: "
            read number
            if [ $number -gt $(($filesCount-1)) ]
            then
                echo "number too big"
                exit 0
            fi
            file=${files[$number]}
        fi
    fi
}

function DoBackup {
    i=0
    origin=""
    destination=""
    maxCopys=0
    infoFileFolders=""
    infoFileBackup=""
    folderName=""

    for item in ${PathList[@]}
    do
        case $i in

            0)
                origin="$item"
                i=$((i+1))
            ;;

            1)
                destinationFolder="$backup_folder/$item/$(date +%d-%m-%Y)"
                destination="$destinationFolder/$item-$(date +%H-%M-%S).tar"
                infoFileFolders="$backup_folder/$item/backupFolders"
                infoFileBackup="$backup_folder/$item/backups-$(date +%d-%m-%Y)"
                infoFileLastBackup="$backup_folder/$item/lastBackup"
                folderName="$item"

                mkdir -p $destinationFolder
                
                echo "$origin" > "$backup_folder/$item/origin"
                                
                lastBackup=""
                if [ -e "$infoFileLastBackup" ]
                then
                    lastBackup=$(cat $infoFileLastBackup)
                fi

                if [ ! -e "$infoFileFolders" ]
                then
                    echo "$(date "+%d-%m-%Y")" > $infoFileFolders
                else
                    if [ "$lastBackup" != "$(date "+%d-%m-%Y")" ]
                    then
                        echo "$(date "+%d-%m-%Y")" >> $infoFileFolders
                    fi
                fi

                if [ ! -e "$infoFileBackup" ]
                then
                    echo "$destination" > $infoFileBackup
                else
                    echo "$destination" >> $infoFileBackup
                fi

                echo "$(date "+%d-%m-%Y")" > $infoFileLastBackup

                i=$((i+1))
            ;;

            2)
                maxCopys=$item
                originPath="$(realpath --relative-to=$(pwd) "$origin")"
                if [ ! -e "$originPath" ]
                then

                    echo "Invalid backup path"
                    exit 0
                fi

                cd $(dirname $originPath)
                tar -vcf "$destination" "$(basename $originPath)"

                if [ ! -z "$GetBackup" ]
                then
                    cp $destination $GetBackup
                fi

                numberOfDates=$(echo $(wc -l $infoFileFolders) | cut -d' ' -f 1)
                readarray -t dates < "$infoFileFolders"
                files=""
                copysToErase=0

                for item2 in ${dates[@]}
                do
                    readarray -t files < "$backup_folder/$folderName/backups-$item2"
                    copyNumber=$(echo $(wc -l $backup_folder/$folderName/backups-$item2) | cut -d' ' -f 1)
                    if [ $copyNumber -gt $maxCopys ]
                    then
                        copysToErase=$(($copyNumber-$maxCopys))
                    fi
                    if [ $copysToErase -gt 0 ]
                    then
                        j=0
                        while [ $j -lt $copysToErase ]
                        do
                            rm "${files[$j]}"
                            erasedCopy[$j]=${files[$j]}
                            j=$(($j+1))
                        done
                    fi
                    
                    rm "$backup_folder/$folderName/backups-$item2"
                    for item3 in ${files[@]}
                    do
                        if [ -e "$item3" ]
                        then
                            echo "$item3" >> "$backup_folder/$folderName/backups-$item2"
                        fi
                    done
                done
                i=0
            ;;

        esac

    done

}

function RestoreFile {
    LoadConfig
    origin=$(cat $1/origin)
    rm -rf "$origin"
    tar -xf $2 --directory $(dirname $origin)
}

function Resotore {
    LoadConfig
    folder="$backup_folder/$1"
    GetFile $folder
    RestoreFile $folder $file
}

function ListAllBackups {
    LoadConfig
    ls $backup_folder
}

function ListBackups {
    LoadConfig
    if [ -z "$1" ]
    then
        echo "Missing argument, expecting backup name"
    fi
    folder=$backup_folder/$1
    if [ ! -e "$folder" ]
    then
        echo "That backup doesn't exist"
        exit 0
    fi
    readarray -t dates < "$folder/backupFolders"
    for item in ${dates[@]}
    do
        echo "$item"
        readarray -t files < "$folder/backups-$item"
        for item2 in ${files[@]}
        do
            echo "  $(basename $item2)"
        done
    done
}

function GetEditor {
    LoadConfig
    if [ -z "$editor" ]
    then
        echo -n "Type the executable of your text editor and press [ENTER]: "
        read editor
        echo "the path to the editor is: $editor"
        echo -n "is that correct? [y/n]: "
        read response
        while [ "$response" != "y" ]
        do
            echo -n "Type the executable of your text editor and press [ENTER]: "
            read editor
            echo "the path to the editor is: $editor"
            echo -n "is that correct? [y/n]: "
            read response
        done
        echo "" >> $CONFIG_FILE
        echo "#your preferred textfile editor" >> $CONFIG_FILE
        echo "editor=$editor" >> $CONFIG_FILE
    fi
}

function EditList {
    GetEditor
    $editor $backup_list
}

function EditConfig {
    GetEditor
    $editor $CONFIG_FILE
}

function RemoveBackup {
    chmod 700 -R $FOLDER >/dev/null 2>&1
    LoadConfig
    folder=$backup_folder/$1
    if [ ! -e $folder ]
    then
        echo "that backup doesn't exist"
    else
        echo "you are about to delete all your backups on: $1"
        echo -n "are you sure? [YES/n]: "
        read response
        if [ "$response" == "YES" ]
        then
            rm -rf $folder
        else
            echo "You scared me :v"
        fi
    fi
}

function RemoveAllData {
    chmod 700 -R $FOLDER >/dev/null 2>&1
    LoadConfig >/dev/null 2>&1
    echo "are you sure you want to DELETE ALL YOUR BACKUPS?"
    echo -n "[YES I'M FUCKING SHURE, SHUT UP AND OBEY ME/n]: "
    read response
    if [ "$response" == "YES I'M FUCKING SHURE, SHUT UP AND OBEY ME" ]
    then
        echo "are you realy realy sure 100%?"
        echo -n "[SHUT UP ALREADY/n]: "
        read response
        if [ "$response" == "SHUT UP ALREADY" ]
        then
            rm -rf $backup_folder
            echo -n "and settings too? [YES/n]: "
            read response
            if [ "$response" == "YES" ]
            then
                WriteConfigFile
                WriteBackupListExample
                echo "sadly, all your data just went bye bye"
            else
                echo "sadly, all your backups just went bye bye"
            fi
        fi
    else
        echo "this time you realy scared me dude"
    fi
}

function DeleteSpecificBackup {
    LoadConfig
    folder="$backup_folder/$1"
    if [ ! -e "$folder" ]
    then
        echo "that backup doesn't exist"
        exit 0
    fi
    GetFile $folder
    echo "Are you sure you wanna delete the folloing backup?:"
    echo "          $file"
    echo -n "[YEy/nO]: "
    read response
    if [ "$response" == "YES" ]
    then
        rm $file
        readarray -t files < "$folder/backups-$date"
        rm "$folder/backups-$date"
        for item in ${files[@]}
        do
            if [ -e "$item" ]
            then
                echo "$item" >> "$folder/backups-$date"
            fi
        done
    else
        exit 0
    fi
}

function ExportAll {
    LoadConfig
    echo "$(basename $CONFIG_FILE)" >> names
    echo "$(basename $backup_list)" >> names
    echo "$(basename $backup_folder)" >> names
    outputFile=$(realpath $1 -L)
    tar -cf $outputFile names
    rm names
    cd $(dirname $backup_folder)
    tar -f $outputFile -r $(basename $backup_folder)
    cd $(dirname $CONFIG_FILE)
    tar -f $outputFile -r $(basename "$CONFIG_FILE")
    cd $(dirname $backup_list)
    tar -f $outputFile -r $(basename "$backup_list")
}

function ImportAll {
    if [ ! -e "$1" ]
    then
        "the file $1 does not exist"
        exit 0
    fi
    tar -xf $1
    readarray -t names < "names"
    configFileName=${names[0]}
    tar -cf $1 $configFileName
    rm -rf $CONFIG_FILE
    mkdir -p $(dirname $CONFIG_FILE)
    mv $configFileName $CONFIG_FILE
    LoadConfig
    rm -rf $backup_list
    mv ${names[1]} $backup_list
    rm -rf $backup_folder
    mv ${names[2]} $backup_folder/
    rm -rf names
    rm $1
}

#get modifiers
declare b=0
declare f=0
declare n=0
declare temporalS
declare RUN_R=0
while getopts ":g: :R :b: :f: :n: :r: :L: :l :h :H :e :E :d: :c :v :I :i :D: :P: :S:" o
do
    case "${o}" in

        g)
            GetBackup="$OPTARG"
        ;;

        R)
            RUN_R=1
        ;;

        b)
            RUN_UNSTORED_BACKUP=true
            temporalS[0]="$OPTARG"
            b=1
        ;;

        f)
            temporalS[1]="$OPTARG"
            inputFile="$OPTARG"
            f=1
        ;;

        n)
            temporalS[3]="$OPTARG"
            n=1
        ;;

        r)
            Resotore "$OPTARG"
        ;;

        l)
            ListAllBackups
        ;;

        L)
            ListBackups "$OPTARG"
        ;;

        e)
            EditList
        ;;

        E)
            EditConfig
        ;;

        h|H)
            PrintHelp
        ;;

        d)
            RemoveBackup "$OPTARG"
        ;;

        c)
            RemoveAllData
        ;;

        v)
            PrintVersion
        ;;

        I)
            Install
        ;;

        i)
            CheckConfig
        ;;

        D)
            DeleteSpecificBackup "$OPTARG"
        ;;

        P)
            ExportAll "$OPTARG"
        ;;

        S)
            ImportAll "$OPTARG"
        ;;

    esac
done

if [ $RUN_R == 1 ]
then
    LoadBackupCfg
    DoBackup
    exit 0
fi

if [ ! -z "$RUN_UNSTORED_BACKUP" ]
then

    if ([ $b == 0 ] || [ $f == 0 ]) && !([ $b == 1 ] && [ $f == 1 ])
    then
        echo "Missing arguments"
        echo ""
        PrintHelp
        exit 0
    fi

    if [ $b ]
    then
        LoadConfig
        if [ $n == 1 ]
        then
            PathList=("${temporalS[1]}" "${temporalS[0]}" "${temporalS[3]}")
        else
            PathList=("${temporalS[1]}" "${temporalS[0]}" "20")
        fi
        DoBackup
    fi
    exit 0
fi

if [ ! -z "$GetBackup" ]
then
    LoadConfig
    echo -n "Type the name of the backup and press [ENTER]: "
    read name
    folder=$backup_folder/$name
    echo "$folder"
    GetFile $folder
    cp $file $GetBackup
fi
